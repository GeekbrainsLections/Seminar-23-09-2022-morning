# Инструкция по работе с Git

## Подготовка репозитория
Для создания репозитория используется команда *git init*. Чтобы созадать репозиторий напишите в терминале с открытой папкой для репозитория *git init*.

## Добавление файлов в репозиторий

Для добавления файла к коммиту используется комманда *git add*. Для этого в терминале с папкой-репозиторием необходимо написать *git add <название файла>*.

## Создание коммита
Для создания коммита используется команда *git commit*. Чтобы создать новый коммит в терминале с открытой папкой-репозиторием пишем команду *git commit -m "<сообщение к коммиту>"*. Сообщения к коммитам писать ***ОБЯЗАТЕЛЬНО***.

## Начало домашнего задания по дополнению инструкции Git


## git reset — возврат к определенному коммиту, откат изменений, «жесткий» или «мягкий»

Помимо работы с индексом (см. выше), git reset позволяет сбросить состояние проекта до какого-либо коммита в истории. В git данное действие может быть двух видов: «мягкого»(soft reset) и «жесткого» (hard reset).

«Мягкий» (с ключом --soft) резет оставит нетронутыми ваши индекс и все дерево файлов и директорий проекта, вернется к работе с указанным коммитом. Иными словами, если вы обнаруживаете ошибку в только что совершенном коммите или комментарии к нему, то легко можно исправить ситуацию:

Некорректный коммит
`git commit`
Переход к работе над уже совершенным коммитом, сохраняя все состояние проекта и проиндексированные файлы
`git reset` `--soft HEAD^`
Редактирование файла или файлов
Добавление файлов в индекс
`git add` .
Возврат к последнему коммиту, будет предложено отредактировать его сообщение
git commit -c ORIG_HEAD
Если сообщение оставить прежним, то достаточно изменить регистр ключа -с
`git commit ` -C ORIG_HEAD
Обратите внимание на обозначение HEAD^, оно означает «обратиться к предку последнего коммита». Подробней описан синтаксис такой относительной адресации будет ниже, в разделе «Хэши, тэги, относительная адресация». Соответственно, HEAD — ссылка на последний коммит. Ссылка ORIG_HEAD после «мягкого» резета указывает на оригинальный коммит.

Естественно, можно вернуться и на большую глубину коммитов,

«Жесткий» резет (ключ --hard) — команда, которую следует использовать с осторожностью. git reset --hard вернет дерево проекта и индекс в состояние, соответствующее указанному коммиту, удалив изменения последующих коммитов:

`git add .
git commit -m «destined to death»
git reset --hard HEAD~1 — больше никто и никогда не увидит этот позорный коммит...
git reset` --hard HEAD~3 — ...вернее, три последних коммита. Никто. Никогда!
Если команда достигнет точки ветвления, удаления коммита не произойдет.

Для команд слияния или выкачивания последних изменений с удаленного репозитория примеры резета будут приведены в соответствующих разделах.

 ## git revert — отмена изменений, произведенных в прошлом отдельным коммитом

 Возможна ситуация, в которой требуется отменить изменения, внесенные отдельным коммитом. git revert создает новый коммит, накладывающий обратные изменения.

Отменяет коммит, помеченный тегом:

`git revert config` -modify-tag
Отменяет коммит, используя его хэш:

`git revert` cgsjd2h
Для отмены коммита слияния (коммита у которого несколько родителей), необходимо указать хэш и номер одного из родителей коммита:

`git revert` cgsjd2h -m 1
Для использования команды необходимо, чтобы состояние проекта не отличалось от состояния, зафиксированного последним коммитом.

## git log — разнообразная информация о коммитах в целом

Иногда требуется получить информацию об истории коммитов; коммитах, изменивших отдельный файл; коммитах за определенный отрезок времени и так далее. Для этих целей используется команда git log.

Простейший пример использования, в котором приводится короткая справка по всем коммитам, коснувшимся активной в настоящий момент ветки (о ветках и ветвлении подробно узнать можно ниже, в разделе «Ветвления и слияния»):

`git log`
Получает подробную информацию о каждом в виде патчей по файлам из коммитов можно, добавив ключ -p (или -u):

`git log -p`
Статистика изменения файлов, вроде числа измененных файлов, внесенных в них строк, удаленных файлов вызывается ключом --stat:

`git log --stat`
За информацию по созданиям, переименованиям и правам доступа файлов отвечает ключ --summary:

`git log --summary`
Чтобы просмотреть историю отдельного файла, достаточно указать в виде параметра его имя (кстати, в моей старой версии git этот способ не срабатывает, обязательно добавлять " — " перед «README»):

`git log README`
или, если версия git не совсем свежая:

`git log — README`
Далее приводится только более современный вариант синтаксиса. Возможно указывать время, начиная в определенного момента («weeks», «days», «hours», «s» и так далее):

`git log --since`=«1 day 2 hours» README
`git log --since`=«2 hours» README
изменения, касающиеся отдельной папки:

g`it log --since`=«2 hours» dir/
Можно отталкиваться от тегов.

Все коммиты, начиная с тега v1:

`git log v1...`
Все коммиты, включающие изменения файла README, начиная с тега v1:

`git log v1... README`
Все коммиты, включающие изменения файла README, начиная с тега v1 и заканчивая тегом v2:

`git log v1..v2 README`
Интересные возможности по формату вывода команды предоставляет ключ --pretty.

Выводит на каждый из коммитов по строчке, состоящей из хэша (здесь — уникального идентификатора каждого коммита, подробней — дальше):

`git log --pretty=oneline`
Лаконичная информация о коммитах, приводятся только автор и комментарий:

`git log --pretty=short`
Более полная информация о коммитах, с именем автора, комментарием, датой создания и внесения коммита:

`git log --pretty=full/fuller`
В принципе, формат вывода можно определить самостоятельно:

`git log --pretty=format:'FORMAT'`
Определение формата можно поискать в разделе по git log из Git Community Book или справке. Красивый ASCII-граф коммитов выводится с использованием ключа --graph.

## Основы работы с удалёнными репозиториями 
***

## git clone — создание копии (удаленного) репозитория

ля начала работы с центральным репозиторием, следует создать копию оригинального проекта со всей его историей локально.

Клонирует репозиторий, используя протокол http:

`git clone` http://user@somehost:port/~user/repository/project.git
Клонирует репозиторий с той же машины в директорию myrepo:

`git clone` /home/username/project myrepo
Клонирует репозиторий, используя безопасный протокол ssh:

`git clone` ssh://user@somehost:port/~user/repository
У git имеется и собственный протокол:

`git clone` git://user@somehost:port/~user/repository/project.git/
Импортирует svn репозиторий, используя протокол http:

`git svn clone `-s http://repo/location
где -s – понимать стандартные папки SVN (trunk, branches, tags)

`git fetch и git pull` — забираем изменения из центрального репозитория
Для синхронизации текущей ветки с репозиторием используются команды git fetch и git pull.

`git fetch` — забирает изменения удаленной ветки из репозитория по умолчания, основной ветки; той, которая была использована при клонировании репозитория. Изменения обновят удаленную ветку (remote tracking branch), после чего надо будет провести слияние с локальной ветку командой git merge.

Получает изменений из определенного репозитория:

`git fetch `/home/username/project
Возможно также использовать синонимы для адресов, создаваемые командой git remote:

`git remote add username`-project /home/username/project
`git fetch username-project`
Естественно, что после оценки изменений, например, командой `git diff`, надо создать коммит слияния с основной:

`git merge username`-project/master
Команда git pull сразу забирает изменения и проводит слияние с активной веткой. Забирает из репозитория, для которого были созданы удаленные ветки по умолчанию:

`git pull`
Забирает изменения и метки из определенного репозитория:

`git pull username`-project --tags
Как правило, используется сразу команда git pull.

## git push — вносим изменения в удаленный репозиторий
После проведения работы в экспериментальной ветке, слияния с основной, необходимо обновить удаленный репозиторий (удаленную ветку). Для этого используется команда git push.

Отправляет свои изменения в удаленную ветку, созданную при клонировании по умолчанию:

`git push`
Отправляет изменения из ветки master в ветку experimental удаленного репозитория:

`git push ssh://yourserver.com/~you/proj.git `master:experimental
В удаленном репозитории origin удаляет ветку experimental:

`git push origin :experimental`
Отправляет в удаленную ветку master репозитория origin (синоним репозитория по умолчанию) ветки локальной ветки master:

`git push origin master:master`
Отправляет метки в удаленную ветку master репозитория origin:

`git push origin master --tags`
Изменяет указатель для удаленной ветке master репозитория origin (master будет такой же как и develop):

`git push origin origin/develop:master`
Добавляет ветку test в удаленный репозиторий origin, указывающую на коммит ветки develop:

`git push origin origin/develop:refs/heads/test`
